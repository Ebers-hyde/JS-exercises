// 1 задание после 2 главы. Изи 

let triangle = ""; // задаем переменную-строку, в которую будем конкатенировать решётки
while (triangle.length < 7) { // Циклом добавляем в строку решётки, пока её длина меньше семёрки и выводим в консоль в каждой итерации
    triangle += "#";
    console.log(triangle);
}

// 2 задание после 2 главы. Изи крейзи тризи. написано, что эта задача повышает стоимость кодера на рынке труда. Я решил с 1 раза. берите на работу

for(let i=1; i<=100;i++) { //Объявляем цикл с начальным значением 1, который перебирает числа до 100 включительно по одному с каждой итерацией
    if(i%3 == 0 && i%5 == 0 ) { //Проверяем кратность числа 3 и 5 с помощью оператора остаток от деления
        console.log("FizzBuzz"); //При истине выводим физбаз
    } else if (i%3 == 0) { //если не проходит - ещё одна проверочка на кратность только 3
        console.log("Fizz"); //выводим физ
    } else if (i%5 == 0) { //и ещё раз если не прошло проверка на кратность 5
        console.log("Buzz"); //выводим баз
    } else { //ни одна не прошла
        console.log(i); //выводим само число
    }
}

// 3 задание после второй главы. С чётным size работает как надо, с нечётным - длина строки больше, чем рядов. Долго сидел, но так и не дошло, как доделать.

let createChess = (size) => { //Создаем функцию, которая принимает размер 
    for (let i=1; i<=size;i++) { //Цикл для добавления строк
        if(i%2 == 0) { //Если строка чётная
            let str = ""; //Объявляется переменная строки
            while(str.length < size) { //Ещё один цикл идёт, пока длина строки меньше заданного размера
                str +="# "; //Каждый раз добавляем к строке такой паттерн
            }
            str+="\n"; //Добавляем перенос на новую строку
            console.log(str); //Выводим строку
        } else { //Всё то же самое для нечётных строк, только обратный паттерн
            let str = "";
            while(str.length < size) {
                str +=" #";
            }
            str+="\n";
            console.log(str);
        }
    }
}

createChess(8);

// 1 задание после третьей главы. Суперизи

let minimum = (a, b) => { //Объявляем функцию с двумя числами
    if (a == b) { // Сначала проверяем на равенство
        return "Числа равны!"; 
    } else if (a < b) { //Потом на то, что меньше первое число
        return a; //Возвращаем его, если проходит
    } else { //Возвращаем второе, если нет
        return b 
    };
}

console.log(minimum(41, 18)); 

// 2 задание после третьей главы. АААА, это тож изи!! Пример из главы мне мозг вынес, и я не думал что вообще с рекурсией справлюсь, но решил с 1 раза!

let isEven=(number)=> { //Объявление функции с аргументом
    if (number == 0) { //Проверяем, если число 0 - значит возвращаем да, оно чётное
        return true;
    } else if (number == 1) { //Если 1, то нечётное
        return false;
    } else { //А тут жара. Если передали не 0 и не 1, запускаем рекурсию, и в каждом новом вызове функции уменьшаем переданное число на 2 до тех пор, пока оно не наткнется на 1 или 0.
        return isEven(number-2);
    } 
}

console.log(isEven(42));

// 3 задание после 3 главы. Само собой изи. 

let countChar = (str, char) => { //Объявляем функцию с параметрами строка и символ, которому нужно посчитать, сколько раз он встречается в строке
    let counter = 0; //Счётчик
    for (i = 0; i<=str.length - 1; i++) { //Цикл, который пробегается по всем символам в строке
        if(str[i] === char) { //Строгая проверка соответствия каждого символа в строке нужному
            counter+=1; //Если да, увеличиваем счётчик
        }
    }
    return counter; //Возвращаем результат
}

console.log(countChar("terminator", "t"));